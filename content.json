{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"wangxue","url":"http://wangxue.github.io"},"pages":[{"title":"tags","date":"2017-03-20T11:45:36.000Z","updated":"2017-03-26T15:51:31.546Z","comments":false,"path":"tags/index.html","permalink":"http://wangxue.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-03-20T11:45:48.000Z","updated":"2017-03-26T15:51:31.546Z","comments":false,"path":"categories/index.html","permalink":"http://wangxue.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"AppWidget的显示和更新","slug":"桌面插件","date":"2017-03-31T13:55:23.510Z","updated":"2017-03-31T14:25:49.641Z","comments":true,"path":"2017/03/31/桌面插件/","link":"","permalink":"http://wangxue.github.io/2017/03/31/桌面插件/","excerpt":"","text":"桌面插件的显示和更新一共涉及到三个应用：systemServer，host，provider。 其中host为显示插件的地方，通常为launcher或者keyguard应用；provider为提供插件内容的应用，如音乐和便签，它们都提供了可以显示在桌面上的小插件；systemServer中提供AppWidgetService，该系统服务统一管理系统中所有已注册的Host，所有可用应用提供的Provider，以及所有已经安装显示的小插件，并负责和host, provider通信实现小插件的显示和更新。 此处以便签的桌面插件为例描述小插件框架的实现和使用。 系统服务AppWidgetService在系统启动过程中，systemServer会启动各种系统服务，其中就包含AppWidgetService public final class SystemServer { private void startOtherServices() { if (!disableNonCoreServices) { if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_APP_WIDGETS)) { mSystemServiceManager.startService(APPWIDGET_SERVICE_CLASS); } } } } 跟踪startService方法，可以看到调用如下： 1.检查com.android.server.appwidget.AppWidgetService是否继承自SystemService类2.调用其构造方法实例化AppWidgetService对象3.将对象添加到SystemServiceManager的队列中，方便在系统的各个启动阶段都可以通知到该服务4.执行AppWidgetService的onStart方法 其中AppWidgetService的代码较少 public class AppWidgetService extends SystemService { private final AppWidgetServiceImpl mImpl; public AppWidgetService(Context context) { super(context); mImpl = new AppWidgetServiceImpl(context); } @Override public void onStart() { // 实名注册系统服务，这样应用通过getSystemService获取到的系统服务实际上是mImpl publishBinderService(Context.APPWIDGET_SERVICE, mImpl); AppWidgetBackupBridge.register(mImpl); } @Override public void onBootPhase(int phase) { if (phase == PHASE_THIRD_PARTY_APPS_CAN_START) { mImpl.setSafeMode(isSafeMode()); } } } 主要是实例化AppWidgetServiceImpl对象，然后实名注册系统服务，在PHASE_THIRD_PARTY_APPS_CAN_START阶段设置safeMode,这样小插件的系统服务就完成启动。 AppWidgetServiceImpl的实例化代码如下： AppWidgetServiceImpl(Context context) { mContext = context; // 获取各种系统服务 mPackageManager = AppGlobals.getPackageManager(); mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE); mUserManager = (UserManager) mContext.getSystemService(Context.USER_SERVICE); mAppOpsManager = (AppOpsManager) mContext.getSystemService(Context.APP_OPS_SERVICE); // 获取一个HanderThread的Handler对象，用于发送消息给子线程保存小插件状态 mSaveStateHandler = BackgroundThread.getHandler(); // 获取主线程的Handler，用于发送消息给主线程更新ui mCallbackHandler = new CallbackHandler(mContext.getMainLooper()); mBackupRestoreController = new BackupRestoreController(); mSecurityPolicy = new SecurityPolicy(); computeMaximumWidgetBitmapMemory(); // 监听系统配置改变，应用安装卸载，用户添加删除等事件 registerBroadcastReceiver(); registerOnCrossProfileProvidersChangedListener(); } 重点看一下其中用来管理已注册Host，可用应用的Provider，已添加的Widget的数据描述 appWidget diagram 添加插件流程Host端代码参考AppWidget创建详解，不再贴出，此处只考虑关键调用 1.实例化appWidgetHost public AppWidgetHost(Context context, int hostId) { this(context, hostId, null, context.getMainLooper()); } /** * @hide */ public AppWidgetHost(Context context, int hostId, OnClickHandler handler, Looper looper) { mContext = context; mHostId = hostId; mOnClickHandler = handler; // 实例化handler，与主线程共用一个Looper,用于通知更新ui mHandler = new UpdateHandler(looper); mDisplayMetrics = context.getResources().getDisplayMetrics(); // 获取AppWidgetService的本地代理，与其通信的服务端为AppWidgetServiceImpl bindService(); } 2.appWidgetHost.startListening public void startListening() { int[] updatedIds; ArrayList&lt;RemoteViews&gt; updatedViews = new ArrayList&lt;RemoteViews&gt;(); try { // 向AWS注册自身，传入IAppWidgetHost.Stub对象，方便AWS回调，同时取得host下所有已添加的widget的信息，包括id和对应的RemoteViews updatedIds = sService.startListening(mCallbacks, mContext.getOpPackageName(), mHostId, updatedViews); } catch (RemoteException e) { throw new RuntimeException(&quot;system server dead?&quot;, e); } final int N = updatedIds.length; for (int i = 0; i &lt; N; i++) { // 更新该host所有已添加的widget updateAppWidgetView(updatedIds[i], updatedViews.get(i)); } } 看一下AWS端startListening的实现 public int[] startListening(IAppWidgetHost callbacks, String callingPackage, int hostId, List&lt;RemoteViews&gt; updatedViews) { final int userId = UserHandle.getCallingUserId(); if (DEBUG) { Slog.i(TAG, &quot;startListening() &quot; + userId); } // Make sure the package runs under the caller uid. mSecurityPolicy.enforceCallFromPackage(callingPackage); synchronized (mLock) { ensureGroupStateLoadedLocked(userId); // NOTE: The lookup is enforcing security across users by making // sure the caller can only access hosts it owns. HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage); Host host = lookupOrAddHostLocked(id); host.callbacks = callbacks; updatedViews.clear(); ArrayList&lt;Widget&gt; instances = host.widgets; int N = instances.size(); int[] updatedIds = new int[N]; // updateViews包含该host中已安装的所有widget对应的RemoteViews,会返回给调用端 for (int i = 0; i &lt; N; i++) { Widget widget = instances.get(i); updatedIds[i] = widget.appWidgetId; updatedViews.add(cloneIfLocalBinder(widget.views)); } // updateIds包含该host中已安装的所有widget对应的id return updatedIds; } } 3.appWidgetHost.allocateWidgetId AppWidgetService收到后会分配一个id，查找到或者新建对应的host对象，然后实例化一个Widget对象并绑定到该host对象，并将信息写入磁盘中。注意此时该widget对象缺少provider信息。 public int allocateAppWidgetId(String callingPackage, int hostId) { final int userId = UserHandle.getCallingUserId(); if (DEBUG) { Slog.i(TAG, &quot;allocateAppWidgetId() &quot; + userId); } // Make sure the package runs under the caller uid. mSecurityPolicy.enforceCallFromPackage(callingPackage); synchronized (mLock) { ensureGroupStateLoadedLocked(userId); if (mNextAppWidgetIds.indexOfKey(userId) &lt; 0) { mNextAppWidgetIds.put(userId, AppWidgetManager.INVALID_APPWIDGET_ID + 1); } final int appWidgetId = incrementAndGetAppWidgetIdLocked(userId); // NOTE: The lookup is enforcing security across users by making // sure the caller can only access hosts it owns. HostId id = new HostId(Binder.getCallingUid(), hostId, callingPackage); Host host = lookupOrAddHostLocked(id); Widget widget = new Widget(); widget.appWidgetId = appWidgetId; widget.host = host; host.widgets.add(widget); mWidgets.add(widget); saveGroupStateAsync(userId); if (DEBUG) { Slog.i(TAG, &quot;Allocated widget id &quot; + appWidgetId + &quot; for host &quot; + host.id); } return appWidgetId; } } 4.appWidgetManager.bindWidgetIdIfAllowed 该方法会传入provider信息，AppWidgetService会调用bindWidgetId方法，根据widget id查找对应的Widget对象，检查是否已绑定Provider对象（正常为未绑定）,绑定Provider对象，然后发送enable/update的广播,同时调用AlarmManager定时发送update广播，将当前widget信息记录到磁盘.provider收到广播后会主动更新插件。 public boolean bindAppWidgetId(String callingPackage, int appWidgetId, int providerProfileId, ComponentName providerComponent, Bundle options) { synchronized (mLock) { // 确保当前用户的小插件信息加载完全 ensureGroupStateLoadedLocked(userId); // 根据widget id找到之前allocate的Widget Widget widget = lookupWidgetLocked(appWidgetId, Binder.getCallingUid(), callingPackage); // 根据信息的provider信息实例化Provider ProviderId providerId = new ProviderId(providerUid, providerComponent); Provider provider = lookupProviderLocked(providerId); widget.provider = provider; widget.options = (options != null) ? cloneIfLocalBinder(options) : new Bundle(); provider.widgets.add(widget); final int widgetCount = provider.widgets.size(); if (widgetCount == 1) { // Tell the provider that it&apos;s ready. sendEnableIntentLocked(provider); } // 发送update广播，provider应用如便签在收到该广播后会执行相应的BroadcastReceiver来更新插件 sendUpdateIntentLocked(provider, new int[] {appWidgetId}); // Schedule the future updates. registerForBroadcastsLocked(provider, getWidgetIds(provider.widgets)); saveGroupStateAsync(userId); } return true; } 6.configure 省略 7.显示小插件 实例化AppWidgetHostView,其中会调用remoteviews.apply AppWidgetProviderInfo appWidgetProviderInfo = appWidgetManager.getAppWidgetInfo(appWidgetId) ; AppWidgetHostView hostView = mAppWidgetHost.createView(MainActivity.this, appWidgetId, appWidgetProviderInfo); int widget_minWidht = appWidgetProviderInfo.minWidth ; int widget_minHeight = appWidgetProviderInfo.minHeight ; //设置长宽 appWidgetProviderInfo 对象的 minWidth 和 minHeight 属性 LinearLayout.LayoutParams linearLayoutParams = new LinearLayout.LayoutParams(widget_minWidht, widget_minHeight); //添加至LinearLayout父视图中 linearLayout.addView(hostView,linearLayoutParams) ; 看一下createView的实现 public final AppWidgetHostView createView(Context context, int appWidgetId, AppWidgetProviderInfo appWidget) { AppWidgetHostView view = onCreateView(mContext, appWidgetId, appWidget); view.setOnClickHandler(mOnClickHandler); view.setAppWidget(appWidgetId, appWidget); synchronized (mViews) { mViews.put(appWidgetId, view); } RemoteViews views; try { // 根据widget id获取该Widget对应的RemoteViews views = sService.getAppWidgetViews(mContext.getOpPackageName(), appWidgetId); } catch (RemoteException e) { throw new RuntimeException(&quot;system server dead?&quot;, e); } // 为该view应用RemoteViews view.updateAppWidget(views); return view; } provider主动更新插件流程provider端一般在两种情况下主动更新插件 1.在host执行appWidgetManager.bindWidgetIdIfAllowed时，provider接收前面提到的enable/disable/update/destroy的广播，provider会实现一个全局的BroadcastReceiver,接收appwidget enable/disable/update/destroy消息 RemoteViews views = new RemoteViews(context.getPackageName(), R.layout.notes_appwidget); Intent intent = null; intent = new Intent(&quot;com.meizu.flyme.notepaper.NoteTranslucentEditActivity&quot;); intent.setFlags(Intent.FLAG_ACTIVITY_NO_HISTORY | Intent.FLAG_ACTIVITY_NO_ANIMATION); views.setOnClickPendingIntent(R.id.new_note, PendingIntent.getActivity(context, 0, intent, 0)); for(int appWidgetId : appWidgetIds){ intent = new Intent(context, NotesPaperRemoteViewService.class); intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId); intent.setData(Uri.parse(intent.toUri(Intent.URI_INTENT_SCHEME))); views.setRemoteAdapter(appWidgetId, R.id.listview, intent); views.setPendingIntentTemplate(R.id.listview, generatPendingIntent(context, -1, NoteUtil.EDIT_TYPE_UPDATE)); views.setEmptyView(R.id.listview, R.id.empty_view); appWidgetManager.updateAppWidget(appWidgetId, views); } 基本做法是实例化一个RemoteViews对象，然后调用appWidgetManager.updateAppWidget方法更新小插件，AppWidgetServiceImpl端的代码如下 private void updateAppWidgetIds(String callingPackage, int[] appWidgetIds, RemoteViews views, boolean partially) { synchronized (mLock) { ensureGroupStateLoadedLocked(userId); final int N = appWidgetIds.length; for (int i = 0; i &lt; N; i++) { final int appWidgetId = appWidgetIds[i]; Widget widget = lookupWidgetLocked(appWidgetId, Binder.getCallingUid(), callingPackage); if (widget != null) { updateAppWidgetInstanceLocked(widget, views, partially); } } } } private void updateAppWidgetInstanceLocked(Widget widget, RemoteViews views, boolean isPartialUpdate) { if (widget != null &amp;&amp; widget.provider != null &amp;&amp; !widget.provider.zombie &amp;&amp; !widget.host.zombie) { if (isPartialUpdate &amp;&amp; widget.views != null) { // For a partial update, we merge the new RemoteViews with the old. widget.views.mergeRemoteViews(views); } else { // For a full update we replace the RemoteViews completely. widget.views = views; } scheduleNotifyUpdateAppWidgetLocked(widget, views); } private void scheduleNotifyUpdateAppWidgetLocked(Widget widget, int viewId) { mCallbackHandler.obtainMessage( CallbackHandler.MSG_NOTIFY_UPDATE_APP_WIDGET, args).sendToTarget(); } mCallbackHandler收到MSG_NOTIFY_UPDATE_APP_WIDGET后的处理方式为 private void handleNotifyUpdateAppWidget(Host host, IAppWidgetHost callbacks, int appWidgetId, RemoteViews views) { try { callbacks.updateAppWidget(appWidgetId, views); } catch (RemoteException re) { synchronized (mLock) { Slog.e(TAG, &quot;Widget host dead: &quot; + host.id, re); host.callbacks = null; } } } 其中callbacks正是host的IAppWidgetHost接口的本地代理，服务端（位于host应用中）的处理方式如下 class Callbacks extends IAppWidgetHost.Stub { public void updateAppWidget(int appWidgetId, RemoteViews views) { if (isLocalBinder() &amp;&amp; views != null) { views = views.clone(); } Message msg = mHandler.obtainMessage(HANDLE_UPDATE, appWidgetId, 0, views); msg.sendToTarget(); } } mHandler消息后会调用updateAppWidgetView方法 // 根据widget id得到对应的AppWidgetHostView，然后使用RemoteViews更新该AppWidgetHostView void updateAppWidgetView(int appWidgetId, RemoteViews views) { AppWidgetHostView v; synchronized (mViews) { v = mViews.get(appWidgetId); } if (v != null) { v.updateAppWidget(views); } } 在添加小插件的过程中，AppWidgetHostView也会查询对应的RemoteViews然后执行AppWidgetHostView.updateAppWidget(RemoteViews views)方法，此处provider更新也是如此，具体看一下 public void updateAppWidget(RemoteViews remoteViews) { boolean recycled = false; View content = null; Exception exception = null; if (remoteViews == null) { if (mViewMode == VIEW_MODE_DEFAULT) { // We&apos;ve already done this -- nothing to do. return; } content = getDefaultView(); mLayoutId = -1; mViewMode = VIEW_MODE_DEFAULT; } else { // 实例化provider端的Context对象，这样主题资源可以和provider保持一致 mRemoteContext = getRemoteContext(); int layoutId = remoteViews.getLayoutId(); // 如果layout相同，则复用该layout if (content == null &amp;&amp; layoutId == mLayoutId) { try { remoteViews.reapply(mContext, mView, mOnClickHandler); content = mView; recycled = true; if (LOGD) Log.d(TAG, &quot;was able to recycled existing layout&quot;); } catch (RuntimeException e) { exception = e; } } // 正常的inflate布局 if (content == null) { try { content = remoteViews.apply(mContext, this, mOnClickHandler); if (LOGD) Log.d(TAG, &quot;had to inflate new layout&quot;); } catch (RuntimeException e) { exception = e; } } mLayoutId = layoutId; mViewMode = VIEW_MODE_CONTENT; } if (content == null) { if (mViewMode == VIEW_MODE_ERROR) { // We&apos;ve already done this -- nothing to do. return ; } Log.w(TAG, &quot;updateAppWidget couldn&apos;t find any view, using error view&quot;, exception); content = getErrorView(); mViewMode = VIEW_MODE_ERROR; } if (!recycled) { prepareView(content); addView(content); } if (mView != content) { removeView(mView); mView = content; } } 其中remoteViews.apply(mContext, this, mOnClickHandler)则是将RemoteViews中定义的各种action应用到对应的view上。 从上面的内容可以看到，添加小插件的过程中，一共有两次执行AppWidgetHostView.updateAppWidget(RemoteViews views)方法，一次是实例化AppWidgetHostView时会向AWS查询对应的RemoteViews然后调用该方法，另外一次是allocateWidgetId时，provider端应用收到update的广播后会实例化一个RemoteViews对象，然后向AWS请求更新小插件。 如果update广播发送失败，则会导致执行AppWidgetHostView.updateAppWidget(RemoteViews views)时传入null，最后host端只会显示原始的layout，而通过RemoteViews添加的点击事件等则无法反映出来。 2.provider通过AppWidgetManager来通知小插件更新数据，该方法只用于更新ListView的数据 AppWidgetManager awm = AppWidgetManager.getInstance(context); int[] appWidgetIds = awm.getAppWidgetIds(new ComponentName(context, NotesAppWidgetProvider.class)); awm.notifyAppWidgetViewDataChanged(appWidgetIds, R.id.listview); AWM端会根据widget id查找对应的IAppWidgetHost对象，然后调用callbacks.viewDataChanged(appWidgetId, viewId) , host端的会调用AppWidgetHostView.viewDataChanged(viewId) void viewDataChanged(int viewId) { View v = findViewById(viewId); if ((v != null) &amp;&amp; (v instanceof AdapterView&lt;?&gt;)) { AdapterView&lt;?&gt; adapterView = (AdapterView&lt;?&gt;) v; Adapter adapter = adapterView.getAdapter(); if (adapter instanceof BaseAdapter) { BaseAdapter baseAdapter = (BaseAdapter) adapter; baseAdapter.notifyDataSetChanged(); } else if (adapter == null &amp;&amp; adapterView instanceof RemoteAdapterConnectionCallback) { // If the adapter is null, it may mean that the RemoteViewsAapter has not yet // connected to its associated service, and hence the adapter hasn&apos;t been set. // In this case, we need to defer the notify call until it has been set. ((RemoteAdapterConnectionCallback) adapterView).deferNotifyDataSetChanged(); } } } 可以看到最终调用的是adapter的nofifyDatasetChanged。","categories":[{"name":"frameworks","slug":"frameworks","permalink":"http://wangxue.github.io/categories/frameworks/"}],"tags":[]},{"title":"jni的基本用法","slug":"jni的基本用法","date":"2017-03-30T06:38:31.019Z","updated":"2017-03-31T14:27:20.443Z","comments":true,"path":"2017/03/30/jni的基本用法/","link":"","permalink":"http://wangxue.github.io/2017/03/30/jni的基本用法/","excerpt":"","text":"jni技术用于实现java与c/c++代码之间的连接,在android平台中被大量运用,比如 本地代码启动java虚拟机，创建java的运行环境，如进程zygote启动后创建java虚拟机 系统服务多用c/c++实现，在其中通过jni提供接口供java代码调用 下面主要讲述jni在常见场景下的使用方法，如java应用如何调用本地库函数，本地库函数如何调用java代码，在c程序中如何创建java虚拟机执行java代码。同时也提到如何注册jni本地函数，建立java本地方法和本地库函数之间的映射以加快运行效率。 在java中调用c库函数 编写java代码，其中需要本地实现的方法用native修饰 class Hello{ native void printHello(); static { System.loadLibrary(&quot;Hello&quot;); } public static void main(String[] args){ Hello hello = new Hello(); hello.printHello(); } } 编译java文件为class文件 $ javac Hello.java 根据java文件生成c语言头文件 $ javah Hello 此时会生成相应的c语言头文件Hello.h /* DO NOT EDIT THIS FILE - it is machine generated */ #include &lt;jni.h&gt; /* Header for class Hello */ #ifndef _Included_Hello #define _Included_Hello #ifdef __cplusplus extern &quot;C&quot; { #endif /* * Class: Hello * Method: printHello * Signature: ()V */ JNIEXPORT void JNICALL Java_Hello_printHello (JNIEnv *, jobject); #ifdef __cplusplus } #endif #endif 自动生成的本地函数名是有规则的，其中JNIEXPORT JNICALL关键字都是在jni.h头文件注册的宏，函数名格式为Java类名本地方法名，这样在加载本地函数库时系统可以找到java本地方法对应的本地函数。 在生成的函数原型中带有两个默认参数，第一个JNIEnv*类型参数是jni接口的指针，用来调用jni表中的各种函数，第二个参数jobject类型参数指的是调用本地方法的对象的引用。如果java本地方法为static类型，则第二个参数为jclass类型。 编写c代码，Hello.c实现头文件中的方法即可，注意添加参数名 #include &quot;Hello.h&quot; #include &lt;stdio.h&gt; /* * Class: Hello * Method: printHello * Signature: ()V */ JNIEXPORT void JNICALL Java_Hello_printHello (JNIEnv *env, jobject obj){ printf(&quot;Hello World!\\n&quot;); } 生成共享库 $ gcc -I/usr/lib/jvm/java-7-oracle/include -I/usr/lib/jvm/java-7-oracle/include/linux -fPIC -shared -o libHello.so Hello.c 此处用-I选项指定头文件jni.h位置，最终编译生成libHello.so文件。 运行java程序，查看结果 $ java -Djava.library.path=. Hello Hello World! 此处Hello.class类执行时需要用-D选项指定动态库的路径。 在c库函数中调用java代码先写一个Main.java类，该类会调用本地库libmain.so中的库函数，在该库函数中演示如下操作： 创建java对象 访问java类静态变量 访问java类静态方法 访问java对象的变量 访问java对象的方法 编写Main类，代码很简单，就是调用c库函数 class Main{ static native void main(); public static void main(String args[]) { System.loadLibrary(&quot;main&quot;); main(); } } 按照javah工具生成Main.h文件，实现本地函数 我们需要在Main.c文件中实现头文件中声明的JNICALL Java_Main_main方法，由于对应的java方法被static修饰，所以此处的第二个函数参数为jclass类型。 #include &quot;Main.h&quot; #include &lt;stdio.h&gt; JNIEXPORT void JNICALL Java_Main_main(JNIEnv *env, jclass clazz){ // 查找JniTest类 jclass targetClass = (*env)-&gt;FindClass(env, &quot;JniTest&quot;); // 查找JniTest类的构造方法 jmethodID constructorId = (*env)-&gt;GetMethodID(env, targetClass, &quot;&lt;init&gt;&quot;, &quot;(I)V&quot;); // 1.生成JniTest对象 jobject newObject = (*env)-&gt;NewObject(env, targetClass, constructorId, 100); printf(&quot;initiate JniTest object.\\n&quot;); // 2.获取JniTest类的静态变量 jfieldID staticFieldId = (*env)-&gt;GetStaticFieldID(env, targetClass, &quot;var1&quot;, &quot;I&quot;); jint var1 = (*env)-&gt;GetStaticIntField(env, targetClass, staticFieldId); // 3.获取JniTest类的普通变量 jfieldID fieldId = (*env)-&gt;GetFieldID(env, targetClass, &quot;var2&quot;, &quot;I&quot;); jint var2 = (*env)-&gt;GetIntField(env, targetClass, fieldId); printf(&quot;var1: %d , var2: %d\\n&quot;, var1, var2); // 4.调用JniTest类的静态方法 jmethodID staticMethodId = (*env)-&gt;GetStaticMethodID(env, targetClass, &quot;getVar1&quot;, &quot;()I&quot;); jint var11 = (*env)-&gt;CallIntMethod(env, newObject, staticMethodId); // 5.调用JniTest类的普通方法 jmethodID methodId = (*env)-&gt;GetMethodID(env, targetClass, &quot;getVar2&quot;, &quot;()I&quot;); jint var22 = (*env)-&gt;CallIntMethod(env, newObject, methodId); printf(&quot;var1: %d , var2: %d\\n&quot;, var11, var22); } 编译运行效果 $ javac Main.java $ gcc -I/usr/lib/jvm/java-7-oracle/include -I/usr/lib/jvm/java-7-oracle/include/linux -fPIC -shared -o libmain.so Main.c $ java -Djava.library.path=. Main initiate JniTest object. var1: 1 , var2: 0 var1: 1 , var2: 100 通过上述代码可以看到，Jni接口指针定义了一系列的查找class，实例化object，查找id，获取/设置field，调用method的方法，例如 jclass FindClass(JNIEnv *env, const char *name) jobject NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...) jfieldID GetFieldID(JNIEnv *env, jclass clazz, const char *name, const char *signature) jmethodID GetMethodID(JNIEnv *env, jclass clazz, const char *name, const char *signature) &lt;jnitype&gt; Get&lt;type&gt;Field(JNIEnv *env, jobject obj, jfieldID fieldID) void Set&lt;Type&gt;Field(JNIEnv *env, jobject obj, jfeildID feildID, &lt;type&gt; value) &lt;jnitype&gt; Call&lt;type&gt;Method(JNIEnv *env, jobject obj, jmethodId methodID, ...) 在调用jni函数时，c与c++调用方式略有不同，例如 jclass clazz = (*env)-&gt;FindClass(env, &quot;JniTest&quot;); // c风格 jclass clazz = env-&gt;FindClass(&quot;JniTest&quot;); // c++风格 在查找id时需要传入java成员变量或者方法的signature，用于描述方法的返回值和参数，可以通过javap命令获取 $javap -s -p JniTest Compiled from &quot;JniTest.java&quot; class JniTest { private static int var1; Signature: I private int var2; Signature: I public JniTest(int); Signature: (I)V public static int getVar1(); Signature: ()I public void setVar2(int); Signature: (I)V public int getVar2(); Signature: ()I static {}; Signature: ()V } 在c程序中创建java运行环境jni提供了一套Invocation api允许c/c++程序在自身内存区域加载java虚拟机，创建java运行环境。在android系统中，zygote进程(即app_process)正是通过该方式启动第一个java虚拟机。 先编写本地程序invocation，其代码invocaiotn.c如下 #include &lt;jni.h&gt; int main() { JNIEnv *env; JavaVM *vm; JavaVMInitArgs vm_args; JavaVMOption options[1]; jint res; jclass cls; jmethodID mid; jstring jstr; jclass stringClass; jobjectArray args; // 1.生成java虚拟机选项 options[0].optionString = &quot;-Djava.class.path=.&quot;; vm_args.version = JNI_VERSION_1_2; vm_args.options = options; vm_args.nOptions = 1; vm_args.ignoreUnrecognized = JNI_TRUE; // 2.生成java虚拟机 res = JNI_CreateJavaVM(&amp;vm, (void**)&amp;env, &amp;vm_args); // 3.查找java类 cls = (*env)-&gt;FindClass(env, &quot;Demo&quot;); // 4.获取java类中的main方法id mid = (*env)-&gt;GetStaticMethodID(env, cls, &quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;); // 5.生成字符串对象，用做main方法的参数 jstr = (*env)-&gt;NewStringUTF(env, &quot;Hello World!&quot;); stringClass = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;); args = (*env)-&gt;NewObjectArray(env, 1, stringClass, jstr); // 6.调用main方法 (*env)-&gt;CallStaticVoidMethod(env, cls, mid, args); // 7.销毁虚拟机 (*vm)-&gt;DestroyJavaVM(vm); } 编译的时候需要jni.h头文件，同时需要链接libjvm.so库，具体编译指令如下 $ gcc -o invocation invocation.c -I/usr/lib/jvm/java-7-oracle/include -I/usr/lib/jvm/java-7-oracle/include/linux -L/usr/lib/jvm/java-7-oracle/jre/lib/amd64/server -ljvm 注意gcc在处理符号链接的时候如果发现处理到-l参数时该库文件没有被左边的参数使用，则会忽略该-l参数，所以最好将-l参数放到最后，避免出现链接错误[undefined reference to `JNI_CreateJavaVM’ linux] (http://stackoverflow.com/questions/16860021/undefined-reference-to-jni-createjavavm-linux) 如下是需要调用的java类 class Demo { public static void main(String args[]) { System.out.println(args[0]); } } 编译java类后，我们就可以执行invocation程序看一下效果 $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/lib/jvm/java-7-oracle/jre/lib/amd64/server $ ./invocation Hello World! 在c程序中注册jni本地函数java虚拟机在运行包含本地方法的java应用程序时，需要经过如下步骤 调用System.loadLibrary()方法，将运行库加载到内存中 java虚拟机检索加载进来的库函数符号，在其中查找与java本地方法拥有相同签名的jni本地函数符号。若找到一致的，则将本地方法映射到具体的JNI本地函数。 jni机制提供了名称为RegisterNatives()jni函数，允许c/c++开发者将jni本地函数和java类的本地方法直接映射在一起，提升运行效率。 加载本地库时注册jni本地函数 在java代码中调用System.loadLibrary()方法时，java虚拟机加载指定的共享库后会检索共享库内的函数符号，检查JNI_OnLoad()函数是否被实现，是则进行调用，否则自动将本地方法与共享库内的jni本地函数符号进行比较匹配。 JNI_OnLoad()函数最基本的功能为确定java虚拟机支持的jni版本，因此该函数必须返回有关jni版本的信息。如下代码为本地代码重写JNI_OnLoad()方法 #include &lt;jni.h&gt; #include &lt;stdio.h&gt; // 实现本地函数 void printHelloNative() { printf(&quot;Hello World!\\n&quot;); } JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved) { JNIEnv* env = NULL; JNINativeMethod nm[1]; jclass cls; if((*vm)-&gt;GetEnv(vm, (void*)&amp;env, JNI_VERSION_1_4) != JNI_OK) { printf(&quot;Error!&quot;); return JNI_ERR; } cls = (*env)-&gt;FindClass(env, &quot;Hello&quot;); nm[0].name = &quot;printHello&quot;; nm[0].signature = &quot;()V&quot;; nm[0].fnPtr = (void *)printHelloNative; // 将Hello.java类中的printHello方法与本地函数printHelloNative绑定 (*env)-&gt;RegisterNatives(env, cls, nm, 1); return JNI_VERSION_1_4; } 按照如下命令编译为libmain.so库文件 $ gcc -fpic -shared -o libmain.so Main.c -I/usr/lib/jvm/java-7-oracle/include -I/usr/lib/jvm/java-7-oracle/include/linux 如下为Hello.java类 class Hello { native static void printHello(); static { System.loadLibrary(&quot;main&quot;); } public static void main(String args[]) { printHello(); } } 编译后运行可以看到成功找到本地函数 $ java -Djava.library.path=. Hello Hello World! 在c程序中注册jni本地函数 如果开发者在c语言中通过invocation api调用java代码，则不必重写JNI_OnLoad()方法，可以直接调用RegisterNatives()方法完成JNI本地函数与JNI本地方法之间的映射。 android系统中zygote进程启动过程(由frameworks/base/cmds/app_prosss/app_main.cpp中main方法调用frameworks/base/core/jni/AndroidRuntime.cpp的AndroidRuntime::start方法实现)中，在启动vm后会先调用AndroidRuntime::startReg(JNIEnv* env)方法将android framework中使用到的各种本地方法先注册，之后才调用com.android.internal.os.ZygoteInit.java类的main方法。 跟踪startReg方法可以看到最终是通过类似如下代码将本地函数与java本地方法建立映射 int register_com_android_internal_os_RuntimeInit(JNIEnv* env) { return jniRegisterNativeMethods(env, &quot;com/android/internal/os/RuntimeInit&quot;, gMethods, NELEM(gMethods)); } 其中jniRegisterNativeMethods方法位于libnativehelper/JNIHelp.cpp中，最终还是通过调用RegisterNatives方法完成注册。 extern &quot;C&quot; int jniRegisterNativeMethods(C_JNIEnv* env, const char* className, const JNINativeMethod* gMethods, int numMethods) { // ... if ((*env)-&gt;RegisterNatives(e, c.get(), gMethods, numMethods) &lt; 0) { char* msg; asprintf(&amp;msg, &quot;RegisterNatives failed for &apos;%s&apos;; aborting...&quot;, className); e-&gt;FatalError(msg); } return 0; }","categories":[{"name":"android","slug":"android","permalink":"http://wangxue.github.io/categories/android/"}],"tags":[]},{"title":"部署hexo博客","slug":"deploy-hexo","date":"2017-03-26T16:08:23.000Z","updated":"2017-03-27T06:12:29.541Z","comments":true,"path":"2017/03/27/deploy-hexo/","link":"","permalink":"http://wangxue.github.io/2017/03/27/deploy-hexo/","excerpt":"","text":"这个博客是由hexo生成的静态博客，使用indigo主题，部署在github page上，此处记录完整的部署过程。 安装node.js和git和hexo此处可以参考hexo官方wiki，https://hexo.io/zh-cn/docs/index.html 生成博客并托管参考https://hexo.io/zh-cn/docs/setup.html需要注意的是由于我们可能在多台电脑操作，或者哪天本地hexo环境破坏，会比较麻烦，所以我将整个hexo project作为一个git库管理，并且托管到github上123456cd &lt;folder&gt;git initgit add . --allgit commit -m &quot;init hexo&quot;git add remote origin git@github.com:wangxue.github.com.sourcegit push origin master 切换主题为indigo参考https://github.com/yscoder/hexo-theme-indigo/wiki/%E5%AE%89%E8%A3%85需要注意的是我们的hexo文件夹本身也是一个git仓库，然后这个themes文件夹中的indigo只能作为一个git submodule那么在下载indigo主题时，需要采用git submodule的方式来操作1git add submodule git@github.com:yscoder/hexo-theme-indigo.git themes/indigo themes/indigo 将来我们在其他电脑上下载自己的博客代码后，同时也需要更新子模块123git clone git@github.com:wangxue.github.io.source hexo-sourcecd hexo-sourcegit submodule update --init --recursive 部署静态网页参考https://hexo.io/zh-cn/docs/ 遇到的问题 ssh -t git@github.com时显示permission denied私钥文件名不对导致 如何删除文章：执行hexo clean，在_post中删除文章，执行hexo -g d重新部署 编译时报错报错如下1234567891011121314151617181920212204:50:25.815 FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path) [Line 7, Column 23] Error: Unable to call `the return value of (posts[&quot;first&quot;])[&quot;updated&quot;][&quot;toISOString&quot;]`, which is undefined or falsey at Object.exports.prettifyError (C:\\source\\github\\wangxue.github.io.source\\node_modules\\nunjucks\\src\\lib.js:34:15) at C:\\source\\github\\wangxue.github.io.source\\node_modules\\nunjucks\\src\\environment.js:486:31 at new_cls.root [as rootRenderFunc] (eval at _compile (C:\\source\\github\\wangxue.github.io.source\\node_modules\\nunjucks\\src\\environment.js:565:24), &lt;anonymous&gt;:161:3) at new_cls.render (C:\\source\\github\\wangxue.github.io.source\\node_modules\\nunjucks\\src\\environment.js:479:15) at Hexo.module.exports (C:\\source\\github\\wangxue.github.io.source\\node_modules\\hexo-generator-feed\\lib\\generator.js:28:22) at Hexo.tryCatcher (C:\\source\\github\\wangxue.github.io.source\\node_modules\\bluebird\\js\\release\\util.js:16:23) at Hexo.&lt;anonymous&gt; (C:\\source\\github\\wangxue.github.io.source\\node_modules\\bluebird\\js\\release\\method.js:15:34) at C:\\source\\github\\wangxue.github.io.source\\node_modules\\hexo\\lib\\hexo\\index.js:337:24 at tryCatcher (C:\\source\\github\\wangxue.github.io.source\\node_modules\\bluebird\\js\\release\\util.js:16:23) at MappingPromiseArray._promiseFulfilled (C:\\source\\github\\wangxue.github.io.source\\node_modules\\bluebird\\js\\release\\map.js:61:38) at MappingPromiseArray.PromiseArray._iterate (C:\\source\\github\\wangxue.github.io.source\\node_modules\\bluebird\\js\\release\\promise_array.js:114:31) at MappingPromiseArray.init (C:\\source\\github\\wangxue.github.io.source\\node_modules\\bluebird\\js\\release\\promise_array.js:78:10) at MappingPromiseArray._asyncInit (C:\\source\\github\\wangxue.github.io.source\\node_modules\\bluebird\\js\\release\\map.js:30:10) at Async._drainQueue (C:\\source\\github\\wangxue.github.io.source\\node_modules\\bluebird\\js\\release\\async.js:138:12) at Async._drainQueues (C:\\source\\github\\wangxue.github.io.source\\node_modules\\bluebird\\js\\release\\async.js:143:10) at Immediate.Async.drainQueues (C:\\source\\github\\wangxue.github.io.source\\node_modules\\bluebird\\js\\release\\async.js:17:14) at runCallback (timers.js:666:20) at tryOnImmediate (timers.js:639:5) at processImmediate [as _immediateCallback] (timers.js:611:5) 搜索后发现暂时无解https://github.com/hexojs/hexo-generator-feed/issues/43屏蔽该插件即可，注意不是按照网友说的在_config.yml中屏蔽，而是直接卸载该模块，之后可以通过执行hexo config查看feed配置项是否还在1npm uninstall hexo-generator-feed --save 需要注意的是在安装hexo的插件时不要用-g参数，而是使用hexo.io及各主题教程中的安装命令，安装的模块位于hexo项目内，hexo generate时才可以引用到，否则会出现异常。","categories":[],"tags":[]}]}